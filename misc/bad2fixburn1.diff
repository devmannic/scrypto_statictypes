diff --git a/examples/badburn1/Cargo.lock b/examples/fixburn1/Cargo.lock
index b3e8efd..524074c 100644
--- a/examples/badburn1/Cargo.lock
+++ b/examples/fixburn1/Cargo.lock
@@ -30,16 +30,6 @@ version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a"
 
-[[package]]
-name = "badburn1"
-version = "0.1.0"
-dependencies = [
- "radix-engine",
- "sbor",
- "scrypto",
- "scrypto_statictypes",
-]
-
 [[package]]
 name = "bencher"
 version = "0.1.5"
@@ -96,6 +86,16 @@ version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9ea835d29036a4087793836fa931b08837ad5e957da9e23886b29586fb9b6650"
 
+[[package]]
+name = "fixburn1"
+version = "0.1.0"
+dependencies = [
+ "radix-engine",
+ "sbor",
+ "scrypto",
+ "scrypto_statictypes",
+]
+
 [[package]]
 name = "generic-array"
 version = "0.14.4"
diff --git a/examples/badburn1/Cargo.toml b/examples/fixburn1/Cargo.toml
index 8f090bd..8f34a9a 100644
--- a/examples/badburn1/Cargo.toml
+++ b/examples/fixburn1/Cargo.toml
@@ -1,5 +1,5 @@
 [package]
-name = "badburn1"
+name = "fixburn1"
 version = "0.1.0"
 edition = "2021"
 
@@ -21,4 +21,7 @@ panic = 'abort'     # Abort on panic.
 crate-type = ["cdylib", "lib"]
 name = "out"
 
+[features]
+default = ["scrypto_statictypes/runtime_typechecks"]
+
 [workspace]
diff --git a/examples/badburn1/src/lib.rs b/examples/fixburn1/src/lib.rs
index 8f64c0f..34978f5 100644
--- a/examples/badburn1/src/lib.rs
+++ b/examples/fixburn1/src/lib.rs
@@ -1,38 +1,44 @@
 use scrypto::prelude::*;
+use scrypto_statictypes::prelude::*;
+
+declare_resource!(FLAM);
+declare_resource!(INFLAM);
 
 blueprint! {
-    struct BadBurn {
+    struct FixBurn {
         // Define what resources and data will be managed by Hello components
-        flam_vault: Vault,
-        inflam_vault: Vault,
+        flam_vault: VaultOf<FLAM>,
+        inflam_vault: VaultOf<INFLAM>,
         auth_def: ResourceDef,
         minter: Vault,
     }
 
-    impl BadBurn {
-        pub fn new() -> (Component, Bucket, Bucket) {
+    impl FixBurn {
+        pub fn new() -> (Component, Bucket, BucketOf<FLAM>) {
             // create one owner badge for auth for the burn_it functino
             let minter = ResourceBuilder::new().new_badge_fixed(1);
             // create 1 minter badge for 2 resources, FLAM and INFLAM
             let owner = ResourceBuilder::new().new_badge_fixed(1);
             // create FLAM and mint 1000
-            let flamable_bucket = ResourceBuilder::new()
+            let flamable_bucket: BucketOf<FLAM> = ResourceBuilder::new()
                 .metadata("name", "BurnMe")
                 .metadata("symbol", "FLAM")
                 .new_token_mutable(minter.resource_def())
-                .mint(1000, minter.borrow());
+                .mint(1000, minter.borrow())
+                .into();
             // create INFLAM and mint 1000
             let inflammable_bucket = ResourceBuilder::new()
                 .metadata("name", "KeepMe")
                 .metadata("symbol", "INFLAM")
                 .new_token_mutable(minter.resource_def())
-                .mint(1000, minter.borrow());
+                .mint(1000, minter.borrow())
+                .into();
 
             // setup component storage
-            let flam_vault = Vault::with_bucket(flamable_bucket.take(800)); // FLAM: 800 stay here, 200 are returned
+            let flam_vault = VaultOf::with_bucket(flamable_bucket.take(800)); // FLAM: 800 stay here, 200 are returned
             let c = Self {
                 flam_vault: flam_vault,
-                inflam_vault: Vault::with_bucket(inflammable_bucket), // all 1000 INFLAM stay here
+                inflam_vault: VaultOf::with_bucket(inflammable_bucket), // all 1000 INFLAM stay here
                 auth_def: owner.resource_def(), // save this so we can use #[auth(auth_def)]
                 minter: Vault::with_bucket(minter), // keep this so we can burn)
             }
@@ -41,7 +47,7 @@ blueprint! {
         }
 
         #[auth(auth_def)]
-        pub fn burn_it(&mut self, incoming: Bucket) -> Bucket {
+        pub fn burn_it(&mut self, incoming: BucketOf<FLAM>) -> BucketOf<INFLAM> {
             // burn all but 5, give back same amount of inflam
             if incoming.amount() > 5.into() {
                 self.flam_vault.put(incoming.take(5));
diff --git a/examples/badburn1/tests/lib.rs b/examples/fixburn1/tests/lib.rs
index aa8ee8c..18e4529 100644
--- a/examples/badburn1/tests/lib.rs
+++ b/examples/fixburn1/tests/lib.rs
@@ -13,7 +13,7 @@ fn test_burn_it() {
 
     // Test the `new` function.
     let transaction = TransactionBuilder::new(&executor)
-        .call_function(package, "BadBurn", "new", vec![], None)
+        .call_function(package, "FixBurn", "new", vec![], None)
         .drop_all_bucket_refs()
         .deposit_all_buckets(account) // needed when returning a bucket
         .build(vec![key])
@@ -80,7 +80,7 @@ fn test_burn_it() {
     assert!(!receipt.success);
 
     // Test the `burn_it` method < 5 of the WRONG TYPE (use INFLAM)
-    // it will succeed (oops)
+    // it will also fail (now that we use scrypto_statictypes with the runtime_typechecks enabled !!!)
     let transaction = TransactionBuilder::new(&executor)
         .call_method(
             component_addr,
@@ -97,5 +97,5 @@ fn test_burn_it() {
         .unwrap();
     let receipt = executor.run(transaction, true).unwrap();
     println!("{:?}\n", receipt);
-    assert!(receipt.success);
+    assert!(!receipt.success);
 }
